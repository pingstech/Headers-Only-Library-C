# ‚öôÔ∏è Generic Ring Buffer (Circular Queue) for Embedded Systems

This is a highly optimized, zero-dynamic-memory-allocation ring buffer implementation designed specifically for resource-constrained embedded systems. It utilizes C preprocessor macros to achieve compile-time type safety and O(1) performance for all core operations.

## ‚ú® Features

* **Zero Dynamic Memory Allocation:** The queue structure and its buffer are defined statically (on the stack or in global/static memory), eliminating the overhead and uncertainty of `malloc`/`free`.
* **Compile-time Type Safety:** The `DECLARE_QUEUE` macro creates unique type definitions and function names based on the data type (`TYPE`) and capacity (`SIZE`), ensuring type safety across different queue instances.
* **O(1) Operations:** All core operations (`push`, `pop`, `count`, `is_empty`) complete in constant time, critical for real-time systems.
* **Overwrite Policy:** The standard `push` function automatically implements a ring buffer overwrite policy when the buffer is full, discarding the oldest element.
* **ISR/Thread Ready:** Internal index and count variables are marked with `volatile` for safe access in simple single-threaded and Interrupt Service Routine (ISR) environments.
    * **Note:** For full thread safety in multi-threaded environments, the caller must implement external locking mechanisms (e.g., disable interrupts, use a mutex).

## üöÄ Quick Usage Example

The library requires only including the header file and using the main declaration macro.

### 1. Basic `uint8_t` Queue

```c
#include "queue.h"

// 1. Declare and initialize a queue for uint8_t with a capacity of 16
DECLARE_QUEUE(uint8_t, 16)

// Define the queue instance
queue_uint8_t_16_t my_u8_queue;
queue_init_uint8_t_16(&my_u8_queue); 

// 2. Push data (Standard push with overwrite policy)
queue_push_uint8_t_16(&my_u8_queue, 0xAA);
queue_push_uint8_t_16(&my_u8_queue, 0xBB);

// 3. Check status and count
size_t count = queue_count_uint8_t_16(&my_u8_queue); // count == 2

// 4. Pop data
uint8_t received_data;
queue_uint8_t_16_status_e status = queue_pop_uint8_t_16(&my_u8_queue, &received_data); 
// received_data == 0xAA (FIFO)

// 5. Check helper macros
// DECLARE_QUEUE_AND_INIT(float, 32, sensor_data_queue);
// size_t memory_usage = QUEUE_MEMORY_BYTES(char, 128); 
````

### 2\. String Queue Example

The library includes helper macros to easily create queues for fixed-size strings.

```c
#include "queue.h"

// Declare a queue for strings up to 32 chars, with a capacity of 8
DECLARE_STRING_QUEUE(32, 8)

queue_string_32_t_8_t my_log_queue;
char buffer[32];

// Initialization
queue_init_string_32_t_8(&my_log_queue); 

// Push strings using the helper (handles strncpy and null termination)
queue_push_string_32_8_helper(&my_log_queue, "System Started");
queue_push_string_32_8_helper(&my_log_queue, "Error Code 42");

// Pop string using the helper
int success = queue_pop_string_32_8_helper(&my_log_queue, buffer, sizeof(buffer));
// buffer contains "System Started"
```

## üõ†Ô∏è Macro Reference

| Macro | Description | Generated Structures/Functions |
| :--- | :--- | :--- |
| `DECLARE_QUEUE(TYPE, SIZE)` | Main macro to define the queue structure and all inline functions. | `queue_TYPE_SIZE_t`, `queue_init_TYPE_SIZE`, `queue_push_TYPE_SIZE`, etc. |
| `DECLARE_QUEUE_STATUS(TYPE, SIZE)` | Defines the status enumeration (e.g., `_OK`, `_ERROR_FULL`). | `queue_TYPE_SIZE_status_e` |
| `DECLARE_STRING_QUEUE(STR_SIZE, Q_SIZE)` | Defines a fixed-length string type and the corresponding queue structure with push/pop helpers. | `string_STR_SIZE_t`, `queue_push_string_..._helper`, etc. |
| `QUEUE_MEMORY_BYTES(TYPE, SIZE)` | Calculates the exact memory footprint in bytes for a given queue definition. | (Calculates memory at compile time) |
| `QUEUE_DECLARE_AND_INIT(TYPE, SIZE, name)` | Utility macro to declare and initialize a queue instance in a single line. | Declares and calls `queue_init...` |

## üì¶ Core Functions (Generated by `DECLARE_QUEUE`)

| Function Name Pattern | Policy | Description |
| :--- | :--- | :--- |
| `queue_init_...` | | Initializes the queue by setting indices and count to zero. |
| `queue_push_...` | **Overwrite** | Adds an element. If full, it increments `read_index` (discarding the oldest data) before writing. |
| `queue_push_no_overwrite_...` | **No Overwrite** | Adds an element. Returns `_ERROR_FULL` if the queue is full. |
| `queue_pop_...` | | Removes and returns the oldest element (FIFO). |
| `queue_pop_multiple_...` | | Removes multiple elements into an array. |
| `queue_peek_...` | | Reads the oldest element without removing it. |
| `queue_peek_ptr_...` | | Returns a `const` pointer to the oldest element in the buffer (allows zero-copy read). |
| `queue_is_empty_...` | | Returns `true` if `count == 0`. |
| `queue_is_full_...` | | Returns `true` if `count >= SIZE`. |
| `queue_count_...` | | Returns the current number of elements in the queue. |
| `queue_clear_...` | | Resets the queue to an empty state. |

## ‚ö†Ô∏è Concurrency Warning

While the internal state variables (`read_index`, `write_index`, `count`) are marked as `volatile` to prevent compiler optimization issues, **the operations themselves are not atomically guaranteed** (e.g., `count++` may be interrupted).

For thread-safe/ISR-safe usage, you **must** wrap all push and pop operations with appropriate synchronization primitives in your calling code:

```c
// Example of required synchronization for ISR safety
void safe_push(queue_uint8_t_16_t* q, uint8_t data) {
    // Platform-specific: Disable interrupts
    uint32_t flags = disable_interrupts(); 
    
    queue_push_uint8_t_16(q, data);
    
    // Platform-specific: Restore interrupts
    restore_interrupts(flags);
}
```